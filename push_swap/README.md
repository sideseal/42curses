# Push_swap

이번 과제에서는 스택에 있는 데이터를 한정된 명령어로 최대한 적은 횟수 내에 정렬해야 한다.

과제에는 정렬해야 하는 int 값들과 두 개의 스택, 그리고 이 스택을 조작하는 명령어 집합이 주어진다.

### Trun-in files
`Makefile`, `push_swap.c`, `*.c`
### 허용 함수
`write`, `read`, `malloc`, `free`, `exit`, 내가 작성했던 도구들(ft_printf ...)

* 프로그램은 작은 숫자가 스택 a의 top에 오도록 순서대로 정렬해야 하고, 사용한 명령어의 목록을 출력한다.
* 명령어는 '\n'으로만 구분되어 출력되어야 한다.
* 오류가 발생했을 경우, 표준 출력으로 `Error`와 줄바꿈 문자(`\n`)을 출력해야 한다.
	* 오류의 예시로는, 특정 인자값이 정수가 아니거나, 정수보다 큰 인자값이 들어오거나, 중복된 인자가 들어오는 경우이다.

## Rules
먼저, 두 개의 스택이 주어진다.
* 스택 a는 랜덤한 개수의 (음과 양의) 정수들을 포함하며, 값은 중복되지 안흔ㄴ다.
* 스택 b는 비어있다.

프로젝트의 목표는 스택 a의 정수들을 오름차순으로 정렬하는 것이다. 다음의 명령어들을 사용할 수 있다.
* `sa` (swap a) : 스택 a의 top에 위치한 두 개의 원소의 순서를 맞바꾼다. 스택 a가 비어있거나 원소가 하나만 있을 경우 아무 동작도 하지 않는다.
* `sb` (swap b) : 스택 b의 top에 위치한 두 개의 원소의 순서를 맞바꾼다. 스택 b가 비어있거나 원소가 하나만 있을 경우 아무 동작도 하지 않는다.
* `ss` : `sa`와 `sb`를 동시에 수행한다.
* `pa` (push a) : 스택 b의 top에 위치한 원소 한 개를 스택 a의 top으로 옮긴다. 스택 a가 비어있을 경우에는 아무 동작도 하지 않는다.
* `pb` (push b) : 스택 a의 top에 위치한 원소 한 개를 스택 b의 top으로 옮긴다. 스택 b가 비어있을 경우에는 아무 동작도 하지 않는다.
* `ra` (rotate a) : 스택 a의 원소를 한 칸씩 위로 옮긴다. 스택의 첫 번째 원소는 맨 마지막 원소가 된다.
* `rb` (rotate b) : 스택 b의 원소를 한 칸씩 위로 옮긴다. 스택의 첫 번째 원소는 맨 마지막 원소가 된다.
* `rr` : `ra`와 `rb`를 동시에 수행한다.
* `rra` (reverse rotate a) : 스택 a의 원소를 한 칸씩 아래로 옮긴다. 스택의 마지막 원소는 맨 첫 번쨰 원소가 된다.
* `rrb` (reverse rotate b) : 스택 b의 원소를 한 칸씩 아래로 옮긴다. 스택의 마지막 원소는 맨 첫 번쨰 원소가 된다.
* `rrr` : `rra`와 `rrb`를 동시에 수행한다.

## 참고점들
* 오류 시 `exit` status 1을 반환하고 종료한다.

## Algorithms

Greedy 탐색법을 사용하였음.

질문점 : 파티셔닝을 할 때, 어떤 때는 3개가 남고, 어떤 떄는 2개가 남는다. 왜그럴까?
